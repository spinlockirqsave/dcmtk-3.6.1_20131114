<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DCMTK: OFStandard Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DCMTK
   &#160;<span id="projectnumber">Version 3.6.1 20131114</span>
   </div>
   <div id="projectbrief">OFFIS DICOM Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classOFStandard-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OFStandard Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A non-POD version of "struct hostent" for thread- and memory-safe data access.  
 <a href="classOFStandard.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ada06320031143da5f04f68826f7b5b3f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">E_MarkupMode</a> { <a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3faea5ae864481ee16f0a99da4fea78715d">MM_HTML</a>, 
<a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3fa47e3f34b8f31923b7d7968c0ab5cb7e7">MM_HTML32</a>, 
<a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3fa802ef3634b97b4fad9effb1955463dcc">MM_XHTML</a>, 
<a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3faf9de720cac130a448fba3a1bdee3592d">MM_XML</a>
 }</td></tr>
<tr class="memdesc:ada06320031143da5f04f68826f7b5b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Markup language mode.  <a href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab71a3f79a81c5c262964ad60674e6b4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab71a3f79a81c5c262964ad60674e6b4d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ab71a3f79a81c5c262964ad60674e6b4d">OFHostent</a> ()</td></tr>
<tr class="memdesc:ab71a3f79a81c5c262964ad60674e6b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor that creates an invalid object. <br/></td></tr>
<tr class="memitem:a3ccea72cdbcdd0a92b31e6424f81b015"><td class="memItemLeft" align="right" valign="top">OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a3ccea72cdbcdd0a92b31e6424f81b015">operator!</a> () const </td></tr>
<tr class="memdesc:a3ccea72cdbcdd0a92b31e6424f81b015"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if a OFHostent object is invalid.  <a href="#a3ccea72cdbcdd0a92b31e6424f81b015"></a><br/></td></tr>
<tr class="memitem:a92028cea7a9a40e42c706d9d51ff170a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a92028cea7a9a40e42c706d9d51ff170a">operator OFBool</a> () const </td></tr>
<tr class="memdesc:a92028cea7a9a40e42c706d9d51ff170a"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if a OFHostent object is valid.  <a href="#a92028cea7a9a40e42c706d9d51ff170a"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab3aaaedae7176ef90b36af8cdf7ee648"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ab3aaaedae7176ef90b36af8cdf7ee648">strlcpy</a> (char *dst, const char *src, size_t siz)</td></tr>
<tr class="memdesc:ab3aaaedae7176ef90b36af8cdf7ee648"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies up to size - 1 characters from the NUL- terminated string src to dst, NUL-terminating the result.  <a href="#ab3aaaedae7176ef90b36af8cdf7ee648"></a><br/></td></tr>
<tr class="memitem:a976613403ca9423d19867b22e92fd663"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a976613403ca9423d19867b22e92fd663">strlcat</a> (char *dst, const char *src, size_t siz)</td></tr>
<tr class="memdesc:a976613403ca9423d19867b22e92fd663"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function appends the NUL-terminated string src to the end of dst.  <a href="#a976613403ca9423d19867b22e92fd663"></a><br/></td></tr>
<tr class="memitem:ad29b92d97c56b8f42dcdf011abfcf201"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ad29b92d97c56b8f42dcdf011abfcf201">strerror</a> (const int errnum, char *buf, const size_t buflen)</td></tr>
<tr class="memdesc:ad29b92d97c56b8f42dcdf011abfcf201"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a given error code to a string.  <a href="#ad29b92d97c56b8f42dcdf011abfcf201"></a><br/></td></tr>
<tr class="memitem:a1d7a81568899f73c7292f155096d5ef1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a1d7a81568899f73c7292f155096d5ef1">toUpper</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;value)</td></tr>
<tr class="memdesc:a1d7a81568899f73c7292f155096d5ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the upper-case version of a given string  <a href="#a1d7a81568899f73c7292f155096d5ef1"></a><br/></td></tr>
<tr class="memitem:ad83a26201452fd4a102edf3f4a719fdc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ad83a26201452fd4a102edf3f4a719fdc">toUpper</a> (<a class="el" href="classOFString.html">OFString</a> &amp;value)</td></tr>
<tr class="memdesc:ad83a26201452fd4a102edf3f4a719fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the upper-case version of a given string.  <a href="#ad83a26201452fd4a102edf3f4a719fdc"></a><br/></td></tr>
<tr class="memitem:a3a21841dc6a358c17415b8422e0084d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a3a21841dc6a358c17415b8422e0084d6">toLower</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;value)</td></tr>
<tr class="memdesc:a3a21841dc6a358c17415b8422e0084d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the lower-case version of a given string  <a href="#a3a21841dc6a358c17415b8422e0084d6"></a><br/></td></tr>
<tr class="memitem:ade3b699ce3361e253f973c6203a92781"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ade3b699ce3361e253f973c6203a92781">toLower</a> (<a class="el" href="classOFString.html">OFString</a> &amp;value)</td></tr>
<tr class="memdesc:ade3b699ce3361e253f973c6203a92781"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the lower-case version of a given string.  <a href="#ade3b699ce3361e253f973c6203a92781"></a><br/></td></tr>
<tr class="memitem:aeb50e3f8a5244165c1aebbc98054e19e"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#aeb50e3f8a5244165c1aebbc98054e19e">pathExists</a> (const <a class="el" href="classOFFilename.html">OFFilename</a> &amp;pathName)</td></tr>
<tr class="memdesc:aeb50e3f8a5244165c1aebbc98054e19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given path exists.  <a href="#aeb50e3f8a5244165c1aebbc98054e19e"></a><br/></td></tr>
<tr class="memitem:acd5f02cb4089df94d5c1d33a0a14df35"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#acd5f02cb4089df94d5c1d33a0a14df35">fileExists</a> (const <a class="el" href="classOFFilename.html">OFFilename</a> &amp;fileName)</td></tr>
<tr class="memdesc:acd5f02cb4089df94d5c1d33a0a14df35"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given file exists.  <a href="#acd5f02cb4089df94d5c1d33a0a14df35"></a><br/></td></tr>
<tr class="memitem:a30e3b75057a7e77c7cb5c9e953e2c5da"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a30e3b75057a7e77c7cb5c9e953e2c5da">dirExists</a> (const <a class="el" href="classOFFilename.html">OFFilename</a> &amp;dirName)</td></tr>
<tr class="memdesc:a30e3b75057a7e77c7cb5c9e953e2c5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given directory exists.  <a href="#a30e3b75057a7e77c7cb5c9e953e2c5da"></a><br/></td></tr>
<tr class="memitem:a9398e9cf3751b6c08634094192580df2"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a9398e9cf3751b6c08634094192580df2">isReadable</a> (const <a class="el" href="classOFFilename.html">OFFilename</a> &amp;pathName)</td></tr>
<tr class="memdesc:a9398e9cf3751b6c08634094192580df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given path is readable.  <a href="#a9398e9cf3751b6c08634094192580df2"></a><br/></td></tr>
<tr class="memitem:ab340446cedb47df0ec3a7bc7d89e11a1"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ab340446cedb47df0ec3a7bc7d89e11a1">isWriteable</a> (const <a class="el" href="classOFFilename.html">OFFilename</a> &amp;pathName)</td></tr>
<tr class="memdesc:ab340446cedb47df0ec3a7bc7d89e11a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given path is writeable.  <a href="#ab340446cedb47df0ec3a7bc7d89e11a1"></a><br/></td></tr>
<tr class="memitem:abc8f1f2a618e927325493857ccde06ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#abc8f1f2a618e927325493857ccde06ea">getDirNameFromPath</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;pathName, const OFBool assumeDirName=OFTrue)</td></tr>
<tr class="memdesc:abc8f1f2a618e927325493857ccde06ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">get directory name component from given path name.  <a href="#abc8f1f2a618e927325493857ccde06ea"></a><br/></td></tr>
<tr class="memitem:ae8f26a515f7ece3677368b94904456bc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ae8f26a515f7ece3677368b94904456bc">getFilenameFromPath</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;pathName, const OFBool assumeFilename=OFTrue)</td></tr>
<tr class="memdesc:ae8f26a515f7ece3677368b94904456bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get file name component from given path name.  <a href="#ae8f26a515f7ece3677368b94904456bc"></a><br/></td></tr>
<tr class="memitem:acb8aab1b29efc9650e072f8010693c9a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#acb8aab1b29efc9650e072f8010693c9a">normalizeDirName</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;dirName, const OFBool allowEmptyDirName=OFFalse)</td></tr>
<tr class="memdesc:acb8aab1b29efc9650e072f8010693c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalize the given directory name.  <a href="#acb8aab1b29efc9650e072f8010693c9a"></a><br/></td></tr>
<tr class="memitem:adf004f61fc88f37e2b70a06b39df8f32"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#adf004f61fc88f37e2b70a06b39df8f32">combineDirAndFilename</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;dirName, const <a class="el" href="classOFString.html">OFString</a> &amp;fileName, const OFBool allowEmptyDirName=OFFalse)</td></tr>
<tr class="memdesc:adf004f61fc88f37e2b70a06b39df8f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">combine the given directory and file name.  <a href="#adf004f61fc88f37e2b70a06b39df8f32"></a><br/></td></tr>
<tr class="memitem:a01389ac3d38be9bcbcfb112b802406fa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFCondition.html">OFCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a01389ac3d38be9bcbcfb112b802406fa">removeRootDirFromPathname</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;rootDir, const <a class="el" href="classOFString.html">OFString</a> &amp;pathName, const OFBool allowLeadingPathSeparator=OFTrue)</td></tr>
<tr class="memdesc:a01389ac3d38be9bcbcfb112b802406fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove root directory prefix from given path name.  <a href="#a01389ac3d38be9bcbcfb112b802406fa"></a><br/></td></tr>
<tr class="memitem:a35c34d1f49d211d85fcf7b7d2c58e28a"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a35c34d1f49d211d85fcf7b7d2c58e28a">searchDirectoryRecursively</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;directory, <a class="el" href="classOFList.html">OFList</a>&lt; <a class="el" href="classOFString.html">OFString</a> &gt; &amp;fileList, const <a class="el" href="classOFString.html">OFString</a> &amp;pattern=&quot;&quot;, const <a class="el" href="classOFString.html">OFString</a> &amp;dirPrefix=&quot;&quot;, const OFBool recurse=OFTrue)</td></tr>
<tr class="memdesc:a35c34d1f49d211d85fcf7b7d2c58e28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">scan a given directory (recursively) and add all filenames found to a list  <a href="#a35c34d1f49d211d85fcf7b7d2c58e28a"></a><br/></td></tr>
<tr class="memitem:a0eaf7a13ff9a973dd58cb0ef44a64cca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFCondition.html">OFCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a0eaf7a13ff9a973dd58cb0ef44a64cca">createDirectory</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;dirName, const <a class="el" href="classOFString.html">OFString</a> &amp;rootDir=&quot;&quot;)</td></tr>
<tr class="memdesc:a0eaf7a13ff9a973dd58cb0ef44a64cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a directory (including sub-directories) if it does not yet exist.  <a href="#a0eaf7a13ff9a973dd58cb0ef44a64cca"></a><br/></td></tr>
<tr class="memitem:add18e3b0ee60bc2f8449fb82b7e221c8"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#add18e3b0ee60bc2f8449fb82b7e221c8">deleteFile</a> (const <a class="el" href="classOFFilename.html">OFFilename</a> &amp;filename)</td></tr>
<tr class="memdesc:add18e3b0ee60bc2f8449fb82b7e221c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete given file from filesystem  <a href="#add18e3b0ee60bc2f8449fb82b7e221c8"></a><br/></td></tr>
<tr class="memitem:add07c3fd14037280d046a6e784968d44"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#add07c3fd14037280d046a6e784968d44">getFileSize</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;filename)</td></tr>
<tr class="memdesc:add07c3fd14037280d046a6e784968d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine size of given file (in bytes)  <a href="#add07c3fd14037280d046a6e784968d44"></a><br/></td></tr>
<tr class="memitem:adc444dea2d11e767c6650e330c95061b"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#adc444dea2d11e767c6650e330c95061b">checkForMarkupConversion</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;sourceString, const OFBool convertNonASCII=OFFalse, const size_t maxLength=0)</td></tr>
<tr class="memdesc:adc444dea2d11e767c6650e330c95061b"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether conversion to a HTML/XML mnenonic string is required.  <a href="#adc444dea2d11e767c6650e330c95061b"></a><br/></td></tr>
<tr class="memitem:ace929c141340f1fa4e244658906666f9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFCondition.html">OFCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ace929c141340f1fa4e244658906666f9">convertToMarkupStream</a> (STD_NAMESPACE ostream &amp;out, const <a class="el" href="classOFString.html">OFString</a> &amp;sourceString, const OFBool convertNonASCII=OFFalse, const <a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">E_MarkupMode</a> markupMode=<a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3faf9de720cac130a448fba3a1bdee3592d">MM_XML</a>, const OFBool newlineAllowed=OFFalse, const size_t maxLength=0)</td></tr>
<tr class="memdesc:ace929c141340f1fa4e244658906666f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert character string to a HTML/XHTML/XML mnenonic stream.  <a href="#ace929c141340f1fa4e244658906666f9"></a><br/></td></tr>
<tr class="memitem:af1756959031f6e64f67c1cc457454c39"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#af1756959031f6e64f67c1cc457454c39">convertToMarkupString</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;sourceString, <a class="el" href="classOFString.html">OFString</a> &amp;markupString, const OFBool convertNonASCII=OFFalse, const <a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">E_MarkupMode</a> markupMode=<a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3faf9de720cac130a448fba3a1bdee3592d">MM_XML</a>, const OFBool newlineAllowed=OFFalse, const size_t maxLength=0)</td></tr>
<tr class="memdesc:af1756959031f6e64f67c1cc457454c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert character string to a HTML/XHTML/XML mnenonic string.  <a href="#af1756959031f6e64f67c1cc457454c39"></a><br/></td></tr>
<tr class="memitem:a6d71dc4ffbee58a8b64ea9e673836458"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a6d71dc4ffbee58a8b64ea9e673836458">checkForOctalConversion</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;sourceString, const size_t maxLength=0)</td></tr>
<tr class="memdesc:a6d71dc4ffbee58a8b64ea9e673836458"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether conversion to an octal format is required.  <a href="#a6d71dc4ffbee58a8b64ea9e673836458"></a><br/></td></tr>
<tr class="memitem:ac73caa3de4a0a60fd8163fcf337d6763"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFCondition.html">OFCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ac73caa3de4a0a60fd8163fcf337d6763">convertToOctalStream</a> (STD_NAMESPACE ostream &amp;out, const <a class="el" href="classOFString.html">OFString</a> &amp;sourceString, const size_t maxLength=0)</td></tr>
<tr class="memdesc:ac73caa3de4a0a60fd8163fcf337d6763"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert character string to an octal format stream.  <a href="#ac73caa3de4a0a60fd8163fcf337d6763"></a><br/></td></tr>
<tr class="memitem:a2db54a0c9d8521c35ff95bf433a5b072"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a2db54a0c9d8521c35ff95bf433a5b072">convertToOctalString</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;sourceString, <a class="el" href="classOFString.html">OFString</a> &amp;octalString, const size_t maxLength=0)</td></tr>
<tr class="memdesc:a2db54a0c9d8521c35ff95bf433a5b072"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert character string to an octal format string.  <a href="#a2db54a0c9d8521c35ff95bf433a5b072"></a><br/></td></tr>
<tr class="memitem:ad8c73d3768e94a2a653ec0c3bf541a30"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFCondition.html">OFCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ad8c73d3768e94a2a653ec0c3bf541a30">encodeBase64</a> (STD_NAMESPACE ostream &amp;out, const unsigned char *data, const size_t length, const size_t width=0)</td></tr>
<tr class="memdesc:ad8c73d3768e94a2a653ec0c3bf541a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">encode binary data according to "Base64" as described in RFC 2045 (MIME).  <a href="#ad8c73d3768e94a2a653ec0c3bf541a30"></a><br/></td></tr>
<tr class="memitem:a51cd8f17965cbb801ba310f97ba5cbf0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a51cd8f17965cbb801ba310f97ba5cbf0">encodeBase64</a> (const unsigned char *data, const size_t length, <a class="el" href="classOFString.html">OFString</a> &amp;result, const size_t width=0)</td></tr>
<tr class="memdesc:a51cd8f17965cbb801ba310f97ba5cbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">encode binary data according to "Base64" as described in RFC 2045 (MIME).  <a href="#a51cd8f17965cbb801ba310f97ba5cbf0"></a><br/></td></tr>
<tr class="memitem:a6dda935a045ecb15af0297c46911a66a"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a6dda935a045ecb15af0297c46911a66a">decodeBase64</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;data, unsigned char *&amp;result)</td></tr>
<tr class="memdesc:a6dda935a045ecb15af0297c46911a66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">decode "Base64" encoded string.  <a href="#a6dda935a045ecb15af0297c46911a66a"></a><br/></td></tr>
<tr class="memitem:a7d7df9cb243dbe2dd23141c3fd2b674a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a7d7df9cb243dbe2dd23141c3fd2b674a">atof</a> (const char *s, OFBool *success=NULL)</td></tr>
<tr class="memdesc:a7d7df9cb243dbe2dd23141c3fd2b674a"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a floating-point number from an ASCII decimal representation to internal double-precision format.  <a href="#a7d7df9cb243dbe2dd23141c3fd2b674a"></a><br/></td></tr>
<tr class="memitem:ad7b6fc5fcf8a280ef6e9d3ca2ef59071"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ad7b6fc5fcf8a280ef6e9d3ca2ef59071">ftoa</a> (char *target, size_t targetSize, double value, unsigned int flags=0, int width=0, int precision=-1)</td></tr>
<tr class="memdesc:ad7b6fc5fcf8a280ef6e9d3ca2ef59071"><td class="mdescLeft">&#160;</td><td class="mdescRight">formats a floating-point number into an ASCII string.  <a href="#ad7b6fc5fcf8a280ef6e9d3ca2ef59071"></a><br/></td></tr>
<tr class="memitem:a3ed820cdabc3f62f4eac6ca9ec0edf7d"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a3ed820cdabc3f62f4eac6ca9ec0edf7d">sleep</a> (unsigned int seconds)</td></tr>
<tr class="memdesc:a3ed820cdabc3f62f4eac6ca9ec0edf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes the current process sleep until seconds seconds have elapsed or a signal arrives which is not ignored  <a href="#a3ed820cdabc3f62f4eac6ca9ec0edf7d"></a><br/></td></tr>
<tr class="memitem:a13f68ebd4ddba0e7ac79c27bcbd5915f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a13f68ebd4ddba0e7ac79c27bcbd5915f">milliSleep</a> (unsigned int millisecs)</td></tr>
<tr class="memdesc:a13f68ebd4ddba0e7ac79c27bcbd5915f"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes the current process sleep until the given number of milliseconds have elapsed or a signal which is not ignored arrives  <a href="#a13f68ebd4ddba0e7ac79c27bcbd5915f"></a><br/></td></tr>
<tr class="memitem:a584d8652b4cb42324fefdee3e52fb6f5"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a584d8652b4cb42324fefdee3e52fb6f5">getProcessID</a> ()</td></tr>
<tr class="memdesc:a584d8652b4cb42324fefdee3e52fb6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the identification of the running process.  <a href="#a584d8652b4cb42324fefdee3e52fb6f5"></a><br/></td></tr>
<tr class="memitem:af1d80e99fa0437dc44b7ea184178da7f"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#af1d80e99fa0437dc44b7ea184178da7f">check32BitAddOverflow</a> (const Uint32 summand1, const Uint32 summand2)</td></tr>
<tr class="memdesc:af1d80e99fa0437dc44b7ea184178da7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the addition of two 32-bit integers yields in an overflow  <a href="#af1d80e99fa0437dc44b7ea184178da7f"></a><br/></td></tr>
<tr class="memitem:a471fc89d082836c5da3738bbc87f7aa9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a471fc89d082836c5da3738bbc87f7aa9">rand_r</a> (unsigned int &amp;seed)</td></tr>
<tr class="memdesc:a471fc89d082836c5da3738bbc87f7aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple but thread safe random number generator.  <a href="#a471fc89d082836c5da3738bbc87f7aa9"></a><br/></td></tr>
<tr class="memitem:a5f0bf0ad904dcec514103c7da40f1589"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFStandard.html#ab71a3f79a81c5c262964ad60674e6b4d">OFHostent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a5f0bf0ad904dcec514103c7da40f1589">getHostByName</a> (const char *name)</td></tr>
<tr class="memdesc:a5f0bf0ad904dcec514103c7da40f1589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe version of gethostbyname.  <a href="#a5f0bf0ad904dcec514103c7da40f1589"></a><br/></td></tr>
<tr class="memitem:ad10e8cff21c561ea07e8e699eddd08c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFStandard.html#ab71a3f79a81c5c262964ad60674e6b4d">OFHostent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ad10e8cff21c561ea07e8e699eddd08c0">getHostByAddr</a> (const char *addr, int len, int type)</td></tr>
<tr class="memdesc:ad10e8cff21c561ea07e8e699eddd08c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe version of gethostbyaddr.  <a href="#ad10e8cff21c561ea07e8e699eddd08c0"></a><br/></td></tr>
<tr class="memitem:a362cbca14ef4211655750bfb0466dc86"><td class="memItemLeft" align="right" valign="top">static OFGroup&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a362cbca14ef4211655750bfb0466dc86">getGrNam</a> (const char *name)</td></tr>
<tr class="memdesc:a362cbca14ef4211655750bfb0466dc86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe version of getgrnam.  <a href="#a362cbca14ef4211655750bfb0466dc86"></a><br/></td></tr>
<tr class="memitem:adcd2c5e5ff1f8bbff36777bfa1353fba"><td class="memItemLeft" align="right" valign="top">static OFPasswd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#adcd2c5e5ff1f8bbff36777bfa1353fba">getPwNam</a> (const char *name)</td></tr>
<tr class="memdesc:adcd2c5e5ff1f8bbff36777bfa1353fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe version of getpwnam.  <a href="#adcd2c5e5ff1f8bbff36777bfa1353fba"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aea6ca75c0307d4e880bea55a9fa8d3b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea6ca75c0307d4e880bea55a9fa8d3b9"></a>
<a class="el" href="classOFString.html">OFString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#aea6ca75c0307d4e880bea55a9fa8d3b9">h_name</a></td></tr>
<tr class="memdesc:aea6ca75c0307d4e880bea55a9fa8d3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">official name of host. <br/></td></tr>
<tr class="memitem:abbb0506ad7b9b040974791c102b4517a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbb0506ad7b9b040974791c102b4517a"></a>
<a class="el" href="classOFVector.html">OFVector</a>&lt; <a class="el" href="classOFString.html">OFString</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#abbb0506ad7b9b040974791c102b4517a">h_aliases</a></td></tr>
<tr class="memdesc:abbb0506ad7b9b040974791c102b4517a"><td class="mdescLeft">&#160;</td><td class="mdescRight">a vector containing all known aliases. <br/></td></tr>
<tr class="memitem:abda82662aeb90d04549e3463c18ae6bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abda82662aeb90d04549e3463c18ae6bf"></a>
<a class="el" href="classOFVector.html">OFVector</a>&lt; <a class="el" href="classOFString.html">OFString</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#abda82662aeb90d04549e3463c18ae6bf">h_addr_list</a></td></tr>
<tr class="memdesc:abda82662aeb90d04549e3463c18ae6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector containing the addresses. <br/></td></tr>
<tr class="memitem:a710c8ff5a155993aafd02d7405cfff9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a710c8ff5a155993aafd02d7405cfff9b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a710c8ff5a155993aafd02d7405cfff9b">h_addrtype</a></td></tr>
<tr class="memdesc:a710c8ff5a155993aafd02d7405cfff9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">host address type. <br/></td></tr>
<tr class="memitem:ac82c8f51b3cb6476b5b25dd8541724c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac82c8f51b3cb6476b5b25dd8541724c1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ac82c8f51b3cb6476b5b25dd8541724c1">h_length</a></td></tr>
<tr class="memdesc:ac82c8f51b3cb6476b5b25dd8541724c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">the length of each address (all have the same length). <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a95488083575766bca4b16091acca6e75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95488083575766bca4b16091acca6e75"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a95488083575766bca4b16091acca6e75">rand_max</a></td></tr>
<tr class="memdesc:a95488083575766bca4b16091acca6e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum value that can be returned by <a class="el" href="classOFStandard.html#a471fc89d082836c5da3738bbc87f7aa9" title="simple but thread safe random number generator.">rand_r()</a> <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">ftoa() processing flags.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These flags can be combined by bit-wise or. </p>
</div></td></tr>
<tr class="memitem:afbc8512bc24b94123411787c2d126b13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbc8512bc24b94123411787c2d126b13"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#afbc8512bc24b94123411787c2d126b13">ftoa_format_e</a></td></tr>
<tr class="memdesc:afbc8512bc24b94123411787c2d126b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use e or E conversion format instead of g or G. <br/></td></tr>
<tr class="memitem:a01c2e202747b725557d5705d2d0d508a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01c2e202747b725557d5705d2d0d508a"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a01c2e202747b725557d5705d2d0d508a">ftoa_format_f</a></td></tr>
<tr class="memdesc:a01c2e202747b725557d5705d2d0d508a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use f or F conversion format instead of g or G. <br/></td></tr>
<tr class="memitem:a967f5c81135e0222b9edb42b5d3d5d00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a967f5c81135e0222b9edb42b5d3d5d00"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a967f5c81135e0222b9edb42b5d3d5d00">ftoa_uppercase</a></td></tr>
<tr class="memdesc:a967f5c81135e0222b9edb42b5d3d5d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use E, F or G conversion format instead of e, f or g. <br/></td></tr>
<tr class="memitem:a61132d71787b968a6cd6b31feebf444c"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a61132d71787b968a6cd6b31feebf444c">ftoa_alternate</a></td></tr>
<tr class="memdesc:a61132d71787b968a6cd6b31feebf444c"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert value to alternate form.  <a href="#a61132d71787b968a6cd6b31feebf444c"></a><br/></td></tr>
<tr class="memitem:a8f4682ec4cee9093d061a3553a135927"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f4682ec4cee9093d061a3553a135927"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a8f4682ec4cee9093d061a3553a135927">ftoa_leftadj</a></td></tr>
<tr class="memdesc:a8f4682ec4cee9093d061a3553a135927"><td class="mdescLeft">&#160;</td><td class="mdescRight">left-justify number be within the field <br/></td></tr>
<tr class="memitem:a691b0efc266c98d3b418c09ce74d11bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a691b0efc266c98d3b418c09ce74d11bc"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a691b0efc266c98d3b418c09ce74d11bc">ftoa_zeropad</a></td></tr>
<tr class="memdesc:a691b0efc266c98d3b418c09ce74d11bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">pad with zeroes instead of blanks <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a340ee8ea746b8399dcbe96e5626b117a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a340ee8ea746b8399dcbe96e5626b117a">OFHostent</a> (hostent *const h)</td></tr>
<tr class="memdesc:a340ee8ea746b8399dcbe96e5626b117a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the constructor that "sucks out" a struct hostent instance.  <a href="#a340ee8ea746b8399dcbe96e5626b117a"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aa21c30d9a33fb433a55612c1d076e036"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#aa21c30d9a33fb433a55612c1d076e036">my_strlcpy</a> (char *dst, const char *src, size_t siz)</td></tr>
<tr class="memdesc:aa21c30d9a33fb433a55612c1d076e036"><td class="mdescLeft">&#160;</td><td class="mdescRight">private implementation of strlcpy.  <a href="#aa21c30d9a33fb433a55612c1d076e036"></a><br/></td></tr>
<tr class="memitem:a359fababea6178d5b259fb75109e66f1"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a359fababea6178d5b259fb75109e66f1">my_strlcat</a> (char *dst, const char *src, size_t siz)</td></tr>
<tr class="memdesc:a359fababea6178d5b259fb75109e66f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">private implementation of strlcat.  <a href="#a359fababea6178d5b259fb75109e66f1"></a><br/></td></tr>
<tr class="memitem:a1b1285ab82274641c1c0a510df9e216d"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a1b1285ab82274641c1c0a510df9e216d">my_sleep</a> (unsigned int seconds)</td></tr>
<tr class="memdesc:a1b1285ab82274641c1c0a510df9e216d"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes the current process sleep until seconds seconds have elapsed or a signal arrives which is not ignored  <a href="#a1b1285ab82274641c1c0a510df9e216d"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5edaee6b8856c0286deafc8513433c18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5edaee6b8856c0286deafc8513433c18"></a>
OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a5edaee6b8856c0286deafc8513433c18">ok</a></td></tr>
<tr class="memdesc:a5edaee6b8856c0286deafc8513433c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal state, OFTrue when valid. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2fcd9aa7955e43e552fe0a851b6b62a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fcd9aa7955e43e552fe0a851b6b62a1"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a2fcd9aa7955e43e552fe0a851b6b62a1">OFStandard</a></td></tr>
<tr class="memdesc:a2fcd9aa7955e43e552fe0a851b6b62a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">only <a class="el" href="classOFStandard.html" title="A non-POD version of &quot;struct hostent&quot; for thread- and memory-safe data access.">OFStandard</a> may instantiate a valid object. <br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A non-POD version of "struct hostent" for thread- and memory-safe data access. </p>
<p>A class for various helper functions.</p>
<p>Wraps the contents of a "struct hostent" instance to a non-POD object containing RAII-style data (e.g. <a class="el" href="classOFString.html" title="a simple string class that implements a subset of std::string.">OFString</a> instead of const char*). To handle the old pointer behavior, OFHostent objects can have an invalid state in which case all members are undefined. You can test whether an OFHostent object is invalid or not with the overloaded operators "operator !" and "operator OFBool". Therefore, it behaves quite the same way as pointers in this regard. </p>
<dl class="section note"><dt>Note</dt><dd>The downside of this non-POD class is that it leads to some unnecessary string copy operations. The resulting performance penalty should be insignificant. However, implementing this class based on auto_ptr / unique_ptr or using c++11 move sematics would prevent that, if somebody thinks it is necessary.</dd></dl>
<p>This class is used to comprise a number of "global" helper functions. </p>
</div><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ada06320031143da5f04f68826f7b5b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">OFStandard::E_MarkupMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Markup language mode. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ada06320031143da5f04f68826f7b5b3faea5ae864481ee16f0a99da4fea78715d"></a>MM_HTML</em>&nbsp;</td><td>
<p>HTML (Hyper Text Markup Language) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ada06320031143da5f04f68826f7b5b3fa47e3f34b8f31923b7d7968c0ab5cb7e7"></a>MM_HTML32</em>&nbsp;</td><td>
<p>HTML 3.2 (Hyper Text Markup Language) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ada06320031143da5f04f68826f7b5b3fa802ef3634b97b4fad9effb1955463dcc"></a>MM_XHTML</em>&nbsp;</td><td>
<p>XHTML (Extensible Hyper Text Markup Language) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ada06320031143da5f04f68826f7b5b3faf9de720cac130a448fba3a1bdee3592d"></a>MM_XML</em>&nbsp;</td><td>
<p>XML (Extensible Markup Language) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a7d7df9cb243dbe2dd23141c3fd2b674a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OFStandard::atof </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OFBool *&#160;</td>
          <td class="paramname"><em>success</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts a floating-point number from an ASCII decimal representation to internal double-precision format. </p>
<p>Unlike the <a class="el" href="classOFStandard.html#a7d7df9cb243dbe2dd23141c3fd2b674a" title="converts a floating-point number from an ASCII decimal representation to internal double-precision fo...">atof()</a> function defined in Posix, this implementation is not affected by a locale setting, the radix character is always assumed to be '.' This implementation does not set errno if the input cannot be parsed and it does not implement special handling for overflow/underflow or NaN values. However, a return code indicates whether or not a successful conversion could be performed. The precision of this implementation is limited to approx. 9 decimal digits. </p>
<dl class="section note"><dt>Note</dt><dd>The use of this implementation can be disabled by defining the macro DISABLE_OFSTD_ATOF at compile time; in this case, the locale dependent Posix implementation of sscanf is used and the application is responsible for making sure that the Posix locale is activated at all times. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A decimal ASCII floating-point number, optionally preceded by white space. Must have form "-I.FE-X", where I is the integer part of the mantissa, F is the fractional part of the mantissa, and X is the exponent. Either of the signs may be "+", "-", or omitted. Either I or F may be omitted, or both. The decimal point isn't necessary unless F is present. The "E" may actually be an "e". E and X may both be omitted (but not just one). </td></tr>
    <tr><td class="paramname">success</td><td>pointer to return status code, may be NULL. if present, a status code is stored in the variable pointed to by this parameter. The status is OFTrue if a conversion could be performed and OFFalse if the string does not have the expected format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>floating-point equivalent of string. If a terminating character is found before any floating-point digits, then zero is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="af1d80e99fa0437dc44b7ea184178da7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::check32BitAddOverflow </td>
          <td>(</td>
          <td class="paramtype">const Uint32&#160;</td>
          <td class="paramname"><em>summand1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint32&#160;</td>
          <td class="paramname"><em>summand2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the addition of two 32-bit integers yields in an overflow </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">summand1</td><td>first integer value to be added </td></tr>
    <tr><td class="paramname">summand2</td><td>second integer value to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if an overflow occurred during the addition, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="adc444dea2d11e767c6650e330c95061b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::checkForMarkupConversion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>convertNonASCII</em> = <code>OFFalse</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLength</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether conversion to a HTML/XML mnenonic string is required. </p>
<p>This check can be performed before <a class="el" href="classOFStandard.html#ace929c141340f1fa4e244658906666f9" title="convert character string to a HTML/XHTML/XML mnenonic stream.">convertToMarkupStream()</a> or <a class="el" href="classOFStandard.html#af1756959031f6e64f67c1cc457454c39" title="convert character string to a HTML/XHTML/XML mnenonic string.">convertToMarkupString()</a> is called in order to speed up the process in case the conversion is not required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceString</td><td>source string to be checked. May contain one or more NULL bytes. </td></tr>
    <tr><td class="paramname">convertNonASCII</td><td>convert non-ASCII characters (&lt; #32 and &gt;= #127) to numeric value (&amp;#nnn;) if OFTrue </td></tr>
    <tr><td class="paramname">maxLength</td><td>maximum number of characters from the source string to be converted. A value of 0 means all characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if markup conversion is required, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a6d71dc4ffbee58a8b64ea9e673836458"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::checkForOctalConversion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLength</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether conversion to an octal format is required. </p>
<p>This check can be performed before <a class="el" href="classOFStandard.html#ac73caa3de4a0a60fd8163fcf337d6763" title="convert character string to an octal format stream.">convertToOctalStream()</a> or <a class="el" href="classOFStandard.html#a2db54a0c9d8521c35ff95bf433a5b072" title="convert character string to an octal format string.">convertToOctalString()</a> is called in order to speed up the process in case the conversion is not required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceString</td><td>source string to be checked. May contain one or more NULL bytes. </td></tr>
    <tr><td class="paramname">maxLength</td><td>maximum number of characters from the source string to be converted. A value of 0 means all characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if markup conversion is required, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="adf004f61fc88f37e2b70a06b39df8f32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::combineDirAndFilename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>dirName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>allowEmptyDirName</em> = <code>OFFalse</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>combine the given directory and file name. </p>
<p>Normalizes the directory name and appends the file name (with a path separator) if not empty. If both 'dirName' and 'fileName' are empty strings and the flag 'allowEmptyDirName' is OFFalse the resulting path name is set to "." (current directory). If 'dirName' is "." and the flag 'allowEmptyDirName' is OFTrue an empty directory name is used. NB: This function neither checks whether the given 'dirName' exists nor whether the resulting path name points to a valid or existing file name. Furthermore, the value of 'dirName' is ignored if 'fileName' starts with a path separator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the resulting path name is stored </td></tr>
    <tr><td class="paramname">dirName</td><td>directory name to be combined with the file name </td></tr>
    <tr><td class="paramname">fileName</td><td>file name to be combined with the directory name </td></tr>
    <tr><td class="paramname">allowEmptyDirName</td><td>flag indicating whether an empty directory name is allowed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting path name (same as 'result') </dd></dl>

</div>
</div>
<a class="anchor" id="ace929c141340f1fa4e244658906666f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFCondition.html">OFCondition</a> OFStandard::convertToMarkupStream </td>
          <td>(</td>
          <td class="paramtype">STD_NAMESPACE ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>convertNonASCII</em> = <code>OFFalse</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">E_MarkupMode</a>&#160;</td>
          <td class="paramname"><em>markupMode</em> = <code><a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3faf9de720cac130a448fba3a1bdee3592d">MM_XML</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>newlineAllowed</em> = <code>OFFalse</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLength</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert character string to a HTML/XHTML/XML mnenonic stream. </p>
<p>Characters with special meaning for HTML/XHTML/XML (e.g. '&lt;' and '&amp;') are replaced by the corresponding mnenonics (e.g. "&amp;lt;" and "&amp;amp;"). If flag 'convertNonASCII' is OFTrue, all characters &lt; #32 and &gt;= #127 are also converted (useful if only HTML 3.2 is supported which does not allow to specify the character set). In HTML 3.2 mode, the quotation mark (") is converted to "&amp;#34;" instead of """ because the latter entity is not defined.
In HTML mode, the apostrophe sign (') is converted to "&amp;#39;" instead of "'" for the same reason. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>stream used for the HTML/XHTML/XML mnenonic output </td></tr>
    <tr><td class="paramname">sourceString</td><td>source string to be converted. May contain one or more NULL bytes. </td></tr>
    <tr><td class="paramname">convertNonASCII</td><td>convert non-ASCII characters (&lt; # 32 and &gt;= #127) to numeric value (&amp;#nnn;) if OFTrue </td></tr>
    <tr><td class="paramname">markupMode</td><td>convert to HTML, HTML 3.2, XHTML or XML markup. LF and CR are encoded as "&amp;#10;" and "&amp;#13;" in XML mode, the flag 'newlineAllowed' has no meaning in this case. </td></tr>
    <tr><td class="paramname">newlineAllowed</td><td>optional flag indicating whether newlines are allowed or not. If they are allowed, the text "&lt;br&gt;" (HTML) or "&lt;br /&gt;" (XHTML) is used, "&amp;para;" otherwise. The following combinations are accepted: LF, CR, LF CR, CF LF. </td></tr>
    <tr><td class="paramname">maxLength</td><td>maximum number of characters from the source string to be converted. A value of 0 means all characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status, always returns EC_Normal </dd></dl>

</div>
</div>
<a class="anchor" id="af1756959031f6e64f67c1cc457454c39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::convertToMarkupString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>markupString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>convertNonASCII</em> = <code>OFFalse</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">E_MarkupMode</a>&#160;</td>
          <td class="paramname"><em>markupMode</em> = <code><a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3faf9de720cac130a448fba3a1bdee3592d">MM_XML</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>newlineAllowed</em> = <code>OFFalse</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLength</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert character string to a HTML/XHTML/XML mnenonic string. </p>
<p>Characters with special meaning for HTML/XHTML/XML (e.g. '&lt;' and '&amp;') are replaced by the corresponding mnenonics (e.g. "&amp;lt;" and "&amp;amp;"). If flag 'convertNonASCII' is OFTrue, all characters &lt; #32 and &gt;= #127 are also converted (useful if only HTML 3.2 is supported which does not allow to specify the character set). In HTML 3.2 mode, the quotation mark (") is converted to "&amp;#34;" instead of """ because the latter entity is not defined.
In HTML mode, the apostrophe sign (') is converted to "&amp;#39;" instead of "'" for the same reason. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceString</td><td>source string to be converted. May also contain one or more NULL bytes. </td></tr>
    <tr><td class="paramname">markupString</td><td>reference to character string where the result should be stored </td></tr>
    <tr><td class="paramname">convertNonASCII</td><td>convert non-ASCII characters (&lt; # 32 and &gt;= #127) to numeric value (&amp;#nnn;) if OFTrue </td></tr>
    <tr><td class="paramname">markupMode</td><td>convert to HTML, HTML 3.2, XHTML or XML markup string. LF and CR are encoded as "@&amp;@#10;" and "@&amp;@#13;" in XML mode, the flag 'newlineAllowed' has no meaning in this case. </td></tr>
    <tr><td class="paramname">newlineAllowed</td><td>optional flag indicating whether newlines are allowed or not. If they are allowed, the text "&lt;br&gt;" (HTML) or "&lt;br /&gt;" (XHTML) is used, "&amp;para;" otherwise. The following combinations are accepted: LF, CR, LF CR, CF LF. </td></tr>
    <tr><td class="paramname">maxLength</td><td>maximum number of characters from the source string to be converted. A value of 0 means all characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to resulting 'markupString' (might be empty if 'sourceString' was empty) </dd></dl>

</div>
</div>
<a class="anchor" id="ac73caa3de4a0a60fd8163fcf337d6763"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFCondition.html">OFCondition</a> OFStandard::convertToOctalStream </td>
          <td>(</td>
          <td class="paramtype">STD_NAMESPACE ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLength</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert character string to an octal format stream. </p>
<p>All non-ASCII and control characters (code &lt; #32 and &gt;= #127) are converted to their octal representation, i.e. to '' where 'ooo' are the three octal digits of the character. All other characters are output as is. See section 6.1.2.3 in DICOM PS 3.5. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>stream used for the output </td></tr>
    <tr><td class="paramname">sourceString</td><td>source string to be converted. May contain one or more NULL bytes. </td></tr>
    <tr><td class="paramname">maxLength</td><td>maximum number of characters from the source string to be converted. A value of 0 means all characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status, always returns EC_Normal </dd></dl>

</div>
</div>
<a class="anchor" id="a2db54a0c9d8521c35ff95bf433a5b072"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::convertToOctalString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>octalString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLength</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert character string to an octal format string. </p>
<p>All non-ASCII and control characters (code &lt; #32 and &gt;= #127) are converted to their octal representation, i.e. to '' where 'ooo' are the three octal digits of the character. All other characters are output as is. See section 6.1.2.3 in DICOM PS 3.5. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceString</td><td>source string to be converted. May contain one or more NULL bytes. </td></tr>
    <tr><td class="paramname">octalString</td><td>reference to character string where the result should be stored </td></tr>
    <tr><td class="paramname">maxLength</td><td>maximum number of characters from the source string to be converted. A value of 0 means all characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to resulting 'octalString' (might be empty if 'sourceString' was empty) </dd></dl>

</div>
</div>
<a class="anchor" id="a0eaf7a13ff9a973dd58cb0ef44a64cca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFCondition.html">OFCondition</a> OFStandard::createDirectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>dirName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>rootDir</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a directory (including sub-directories) if it does not yet exist. </p>
<p>In other words, this function creates directories recursively, i.e. with all sub-components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirName</td><td>name of the directory to be created </td></tr>
    <tr><td class="paramname">rootDir</td><td>optional name of a root directory (prefix of 'dirName') that already exists and that can, therefore, be skipped during the creation of sub-directories. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status, EC_Normal if successful (directory created or already exists), an error code otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a6dda935a045ecb15af0297c46911a66a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::decodeBase64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>decode "Base64" encoded string. </p>
<p>Any character that does not belong to the Base64 alphabet (0..9, A..Z, a..z, + and /) is ignored when decoding the input string. This is especially true for line breaks which are usually contained in MIME (RFC 2045) encoded streams (see above). The first occurrence of a '=' character is taken as evidence that the end of the data has been reached. NB: The memory buffer in which the binary output is stored is allocated inside this function and has to to be freed (using "delete[]") by the caller! Do not pass a pointer to an already allocated buffer to this function, the caller does not know the exact size anyway. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Base64 encoded input data (possibly padded with '=' at the end) </td></tr>
    <tr><td class="paramname">result</td><td>receives pointer to resulting buffer with binary data (big endian encoded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the resulting binary data (0 if an error occurred, in this case the buffer is deleted internally) </dd></dl>

</div>
</div>
<a class="anchor" id="add18e3b0ee60bc2f8449fb82b7e221c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::deleteFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFFilename.html">OFFilename</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delete given file from filesystem </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of the file (including directory) to delete. This filename may contain wide characters if support enabled. Since there are various constructors for the <a class="el" href="classOFFilename.html" title="class for managing filenames consisting either of conventional (8-bit) or wide (e.g.">OFFilename</a> class, a "char *", "OFString" or "wchar_t *" can also be passed directly to this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if deletion was successful, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a30e3b75057a7e77c7cb5c9e953e2c5da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::dirExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFFilename.html">OFFilename</a> &amp;&#160;</td>
          <td class="paramname"><em>dirName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the given directory exists. </p>
<p>This function also checks that the specified path points to directory and not to a file (or the like). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirName</td><td>name of the directory to be checked. This directory name may contain wide characters if support enabled. Since there are various constructors for the <a class="el" href="classOFFilename.html" title="class for managing filenames consisting either of conventional (8-bit) or wide (e.g.">OFFilename</a> class, a "char *", "OFString" or "wchar_t *" can also be passed directly to this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if directory exists, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad8c73d3768e94a2a653ec0c3bf541a30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFCondition.html">OFCondition</a> OFStandard::encodeBase64 </td>
          <td>(</td>
          <td class="paramtype">STD_NAMESPACE ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>encode binary data according to "Base64" as described in RFC 2045 (MIME). </p>
<p>Basic algorithm: groups of 3 bytes from the binary input are coded as groups of 4 bytes in the textual output. The input data is 'padded' with zeros to create a length that is an even multiple of 3. A special character ('=') is used to denote padding so that the output can be decoded back to its exact size. If the input data is NULL an error code (EC_IllegalParameter) is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream used for the base64 encoded data </td></tr>
    <tr><td class="paramname">data</td><td>buffer with binary data to be encoded (big endian required!) </td></tr>
    <tr><td class="paramname">length</td><td>length of the input data buffer (in bytes) </td></tr>
    <tr><td class="paramname">width</td><td>maximum number of characters per line in the output stream (default: 0 = no line breaks, typical for MIME = 72) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status, EC_Normal if successful, an error code otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a51cd8f17965cbb801ba310f97ba5cbf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::encodeBase64 </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>encode binary data according to "Base64" as described in RFC 2045 (MIME). </p>
<p>Basic algorithm: groups of 3 bytes from the binary input are coded as groups of 4 bytes in the textual output. The input data is 'padded' with zeros to create a length that is an even multiple of 3. A special character ('=') is used to denote padding so that the output can be decoded back to its exact size. If the input data is NULL an empty string is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>buffer with binary data to be encoded (big endian required!) </td></tr>
    <tr><td class="paramname">length</td><td>length of the input data buffer (in bytes) </td></tr>
    <tr><td class="paramname">result</td><td>reference to resulting string variable (Base64 encoded) </td></tr>
    <tr><td class="paramname">width</td><td>maximum number of characters per line in the output string (default: 0 = no line breaks, typical for MIME = 72) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting string </dd></dl>

</div>
</div>
<a class="anchor" id="acd5f02cb4089df94d5c1d33a0a14df35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::fileExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFFilename.html">OFFilename</a> &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the given file exists. </p>
<p>This function also checks that the specified path points to file and not to a directory (or the like). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>name of the file to be checked. This filename may contain wide characters if support enabled. Since there are various constructors for the <a class="el" href="classOFFilename.html" title="class for managing filenames consisting either of conventional (8-bit) or wide (e.g.">OFFilename</a> class, a "char *", "OFString" or "wchar_t *" can also be passed directly to this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if file exists, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad7b6fc5fcf8a280ef6e9d3ca2ef59071"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OFStandard::ftoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>targetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>formats a floating-point number into an ASCII string. </p>
<p>This function works similar to sprintf(), except that this implementation is not affected by a locale setting. The radix character is always '.'. This implementation guarantees that the given string size is always respected by using strlcpy to copy the formatted string into the target buffer. </p>
<dl class="section note"><dt>Note</dt><dd>The use of this implementation can be disabled by defining the macro DISABLE_OFSTD_FTOA at compile time; in this case, the locale dependent Posix implementation of sprintf is used and the application is responsible for making sure that the Posix locale is activated at all times. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>pointer to target string buffer </td></tr>
    <tr><td class="paramname">targetSize</td><td>size of target string buffer </td></tr>
    <tr><td class="paramname">value</td><td>double value to be formatted </td></tr>
    <tr><td class="paramname">flags</td><td>processing flags. Any of the flags defined below can be combined by bit-wise or. </td></tr>
    <tr><td class="paramname">width</td><td>width from format (%8d), or 0 </td></tr>
    <tr><td class="paramname">precision</td><td>precision from format (%.3d), or -1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc8f1f2a618e927325493857ccde06ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::getDirNameFromPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>pathName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>assumeDirName</em> = <code>OFTrue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get directory name component from given path name. </p>
<p>Extracts the substring before the last path separator. If there is no path separator in the given path name, the value of 'pathName' is returned by default; if 'assumeDirName' is OFFalse, an empty string is returned. NB: This function neither checks whether the given 'pathName' exists nor whether the resulting name points to a valid or existing directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the resulting directory name is stored </td></tr>
    <tr><td class="paramname">pathName</td><td>path name from which the directory name should be extracted </td></tr>
    <tr><td class="paramname">assumeDirName</td><td>assume that there always is a directory name in 'pathName' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting directory name (same as 'result') </dd></dl>

</div>
</div>
<a class="anchor" id="ae8f26a515f7ece3677368b94904456bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::getFilenameFromPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>pathName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>assumeFilename</em> = <code>OFTrue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get file name component from given path name. </p>
<p>Extracts the substring after the last path separator. If there is no path separator in the given path name, the value of 'pathName' is returned by default; if 'assumeFilename' is OFFalse, an empty string is returned. NB: This function neither checks whether the given 'pathName' exists nor whether the resulting name points to a valid or existing file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the resulting file name is stored </td></tr>
    <tr><td class="paramname">pathName</td><td>path name from which the file name should be extracted </td></tr>
    <tr><td class="paramname">assumeFilename</td><td>assume that there always is a file name in 'pathName' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting file name (same as 'result') </dd></dl>

</div>
</div>
<a class="anchor" id="add07c3fd14037280d046a6e784968d44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::getFileSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>determine size of given file (in bytes) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of the file to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of the file in bytes (0 in case of error) </dd></dl>

</div>
</div>
<a class="anchor" id="a362cbca14ef4211655750bfb0466dc86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFGroup OFStandard::getGrNam </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread-safe version of getgrnam. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the group name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a OFStandard::OFGroup object. </dd></dl>

</div>
</div>
<a class="anchor" id="ad10e8cff21c561ea07e8e699eddd08c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFStandard.html#ab71a3f79a81c5c262964ad60674e6b4d">OFHostent</a> OFStandard::getHostByAddr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread-safe version of gethostbyaddr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>see manpage. </td></tr>
    <tr><td class="paramname">len</td><td>see manpage. </td></tr>
    <tr><td class="paramname">type</td><td>see manpage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classOFStandard.html#ab71a3f79a81c5c262964ad60674e6b4d" title="default constructor that creates an invalid object.">OFStandard::OFHostent</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f0bf0ad904dcec514103c7da40f1589"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFStandard.html#ab71a3f79a81c5c262964ad60674e6b4d">OFHostent</a> OFStandard::getHostByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread-safe version of gethostbyname. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the host name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classOFStandard.html#ab71a3f79a81c5c262964ad60674e6b4d" title="default constructor that creates an invalid object.">OFStandard::OFHostent</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a584d8652b4cb42324fefdee3e52fb6f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long OFStandard::getProcessID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the identification of the running process. </p>
<dl class="section return"><dt>Returns</dt><dd>the process ID of the currently running process. </dd></dl>

</div>
</div>
<a class="anchor" id="adcd2c5e5ff1f8bbff36777bfa1353fba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFPasswd OFStandard::getPwNam </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread-safe version of getpwnam. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the username. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a OFStandard::OFPasswd object. </dd></dl>

</div>
</div>
<a class="anchor" id="a9398e9cf3751b6c08634094192580df2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::isReadable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFFilename.html">OFFilename</a> &amp;&#160;</td>
          <td class="paramname"><em>pathName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the given path is readable. </p>
<p>This function works for both files and directories. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathName</td><td>name of the path to be checked. This path name may contain wide characters if support enabled. Since there are various constructors for the <a class="el" href="classOFFilename.html" title="class for managing filenames consisting either of conventional (8-bit) or wide (e.g.">OFFilename</a> class, a "char *", "OFString" or "wchar_t *" can also be passed directly to this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if path is readable, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ab340446cedb47df0ec3a7bc7d89e11a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::isWriteable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFFilename.html">OFFilename</a> &amp;&#160;</td>
          <td class="paramname"><em>pathName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the given path is writeable. </p>
<p>This function works for both files and directories. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathName</td><td>name of the path to be checked. This path name may contain wide characters if support enabled. Since there are various constructors for the <a class="el" href="classOFFilename.html" title="class for managing filenames consisting either of conventional (8-bit) or wide (e.g.">OFFilename</a> class, a "char *", "OFString" or "wchar_t *" can also be passed directly to this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if path is writeable, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a13f68ebd4ddba0e7ac79c27bcbd5915f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OFStandard::milliSleep </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>millisecs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>makes the current process sleep until the given number of milliseconds have elapsed or a signal which is not ignored arrives </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">millisecs</td><td>number of milliseconds to sleep </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b1285ab82274641c1c0a510df9e216d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int OFStandard::my_sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>makes the current process sleep until seconds seconds have elapsed or a signal arrives which is not ignored </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>number of seconds to sleep </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the requested time has elapsed, or the number of seconds left to sleep </dd></dl>

</div>
</div>
<a class="anchor" id="a359fababea6178d5b259fb75109e66f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::my_strlcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>private implementation of strlcat. </p>
<p>Called when strlcat is not available in the standard library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination buffer of size siz, must not be NULL </td></tr>
    <tr><td class="paramname">src</td><td>source string, must not be NULL </td></tr>
    <tr><td class="paramname">siz</td><td>size of destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total length of the string the function tried to create, i.e. the initial length of dst plus the length of src </dd></dl>

</div>
</div>
<a class="anchor" id="aa21c30d9a33fb433a55612c1d076e036"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::my_strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>private implementation of strlcpy. </p>
<p>Called when strlcpy is not available in the standard library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination buffer of size siz, must not be NULL </td></tr>
    <tr><td class="paramname">src</td><td>source string, must not be NULL </td></tr>
    <tr><td class="paramname">siz</td><td>size of destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total length of the string the function tried to create, i.e. strlen(src) </dd></dl>

</div>
</div>
<a class="anchor" id="acb8aab1b29efc9650e072f8010693c9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::normalizeDirName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>dirName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>allowEmptyDirName</em> = <code>OFFalse</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>normalize the given directory name. </p>
<p>Removes trailing path separators from the directory name. If the resulting directory name is an empty string and the flag 'allowEmptyDirName' is OFFalse the directory name is set to "." (current directory). If the resulting directory name is "." and the flag 'allowEmptyDirName' is OFTrue the directory name is set to an empty string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the resulting directory name is stored </td></tr>
    <tr><td class="paramname">dirName</td><td>directory name to be normalized </td></tr>
    <tr><td class="paramname">allowEmptyDirName</td><td>flag indicating whether an empty directory name is allowed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting directory name (same as 'result') </dd></dl>

</div>
</div>
<a class="anchor" id="a340ee8ea746b8399dcbe96e5626b117a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFStandard::OFHostent </td>
          <td>(</td>
          <td class="paramtype">hostent *const&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the constructor that "sucks out" a struct hostent instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>the struct hostent instance to clone into this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92028cea7a9a40e42c706d9d51ff170a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OFStandard::operator OFBool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>test if a OFHostent object is valid. </p>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if the object is valid, otherwise OFFalse. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ccea72cdbcdd0a92b31e6424f81b015"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OFBool OFStandard::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>test if a OFHostent object is invalid. </p>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if the object is invalid, otherwise OFFalse. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb50e3f8a5244165c1aebbc98054e19e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::pathExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFFilename.html">OFFilename</a> &amp;&#160;</td>
          <td class="paramname"><em>pathName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the given path exists. </p>
<p>This function does not distinguish files from directories (use '<a class="el" href="classOFStandard.html#acd5f02cb4089df94d5c1d33a0a14df35" title="check whether the given file exists.">fileExists()</a>' or 'directoryExists()' if required). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathName</td><td>name of the path to be checked. This path name may contain wide characters if support enabled. Since there are various constructors for the <a class="el" href="classOFFilename.html" title="class for managing filenames consisting either of conventional (8-bit) or wide (e.g.">OFFilename</a> class, a "char *", "OFString" or "wchar_t *" can also be passed directly to this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if path exists, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a471fc89d082836c5da3738bbc87f7aa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OFStandard::rand_r </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>simple but thread safe random number generator. </p>
<p>The interface is derived from the Posix rand_r function. Uses a multiplicative congruential random-number generator with period 2**32 that returns successive pseudo-random numbers in the range of 0 to randr_max (0x7fffffff). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>pointer to seed of random number generator, must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pseudo-random number in the range of 0 to myrandr_max. </dd></dl>

</div>
</div>
<a class="anchor" id="a01389ac3d38be9bcbcfb112b802406fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFCondition.html">OFCondition</a> OFStandard::removeRootDirFromPathname </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>rootDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>pathName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>allowLeadingPathSeparator</em> = <code>OFTrue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove root directory prefix from given path name. </p>
<p>In case 'pathName' starts with 'rootDir', the common prefix is removed. Otherwise, an empty string is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the resulting path name is stored </td></tr>
    <tr><td class="paramname">rootDir</td><td>name of the root directory to be removed </td></tr>
    <tr><td class="paramname">pathName</td><td>path name from which the root directory (prefix) is removed </td></tr>
    <tr><td class="paramname">allowLeadingPathSeparator</td><td>flag indicating whether a leading path separator is allowed for the resulting path name (automatically removed otherwise) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status, EC_Normal if successful, an error code otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a35c34d1f49d211d85fcf7b7d2c58e28a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::searchDirectoryRecursively </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFList.html">OFList</a>&lt; <a class="el" href="classOFString.html">OFString</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>dirPrefix</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>OFTrue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scan a given directory (recursively) and add all filenames found to a list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>name of the directory to be scanned </td></tr>
    <tr><td class="paramname">fileList</td><td>list to which the filenames are added. Please note that the list is not not cleared automatically. </td></tr>
    <tr><td class="paramname">pattern</td><td>optional wildcard pattern used to match the filenames against. By default all files match. In order to work under Unix the system function fnmatch() is required. </td></tr>
    <tr><td class="paramname">dirPrefix</td><td>optional prefix added to the directory name. This prefix will, however, not be part of the filenames added to the list. </td></tr>
    <tr><td class="paramname">recurse</td><td>flag indicating whether to search recursively (default) or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of new files added to the list </dd></dl>

</div>
</div>
<a class="anchor" id="a3ed820cdabc3f62f4eac6ca9ec0edf7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int OFStandard::sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>makes the current process sleep until seconds seconds have elapsed or a signal arrives which is not ignored </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>number of seconds to sleep </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the requested time has elapsed, or the number of seconds left to sleep </dd></dl>

</div>
</div>
<a class="anchor" id="ad29b92d97c56b8f42dcdf011abfcf201"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* OFStandard::strerror </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>errnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a given error code to a string. </p>
<p>This function wraps the various approaches found on different systems. Internally, the standard function <a class="el" href="classOFStandard.html#ad29b92d97c56b8f42dcdf011abfcf201" title="convert a given error code to a string.">strerror()</a> or strerror_r() is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errnum</td><td>error code to be converted </td></tr>
    <tr><td class="paramname">buf</td><td>buffer which is used to store the result string (if supported) </td></tr>
    <tr><td class="paramname">buflen</td><td>size if the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to string describing the error code. Please note that depending on the implementation of the function used, the result may or may not be a pointer to buf. The return value can also be NULL if the buffer is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a976613403ca9423d19867b22e92fd663"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::strlcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function appends the NUL-terminated string src to the end of dst. </p>
<p>It will append at most size - strlen(dst) - 1 bytes, NUL- terminating the result. It is designed to be a safer, more consistent, and less error-prone replacement for strncat(3). strlcat takes the full size of the buffer (not just the length) and guarantees to NUL-terminate the result (as long as size is larger than 0). Note that you should include a byte for the NUL in size. Also note that strlcat only operates on true C strings, i. e. dst and src must be NUL-terminated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination buffer of size siz, must not be NULL </td></tr>
    <tr><td class="paramname">src</td><td>source string, must not be NULL </td></tr>
    <tr><td class="paramname">siz</td><td>size of destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total length of the string the function tried to create, i.e. the initial length of dst plus the length of src. While this may seem somewhat confusing it was done to make truncation detection simple. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3aaaedae7176ef90b36af8cdf7ee648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function copies up to size - 1 characters from the NUL- terminated string src to dst, NUL-terminating the result. </p>
<p>It is designed to be a safer, more consistent, and less error-prone replacement for strncpy(3). strlcpy takes the full size of the buffer (not just the length) and guarantees to NUL-terminate the result (as long as size is larger than 0). Note that you should include a byte for the NUL in size. Also note that strlcpy only operates on true C strings, i. e. src must be NUL-terminated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination buffer of size siz, must not be NULL </td></tr>
    <tr><td class="paramname">src</td><td>source string, must not be NULL </td></tr>
    <tr><td class="paramname">siz</td><td>size of destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total length of the string the function tried to create, i.e. strlen(src). While this may seem somewhat confusing it was done to make truncation detection simple. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a21841dc6a358c17415b8422e0084d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::toLower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the lower-case version of a given string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the result is stored </td></tr>
    <tr><td class="paramname">value</td><td>string value to be converted to lower case </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting string (same as 'result') </dd></dl>

</div>
</div>
<a class="anchor" id="ade3b699ce3361e253f973c6203a92781"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::toLower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the lower-case version of a given string. </p>
<p>NB: This function changes the parameter 'value'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>string value to be converted to lower case </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting string (same as 'value') </dd></dl>

</div>
</div>
<a class="anchor" id="a1d7a81568899f73c7292f155096d5ef1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::toUpper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the upper-case version of a given string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the result is stored </td></tr>
    <tr><td class="paramname">value</td><td>string value to be converted to upper case </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting string (same as 'result') </dd></dl>

</div>
</div>
<a class="anchor" id="ad83a26201452fd4a102edf3f4a719fdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::toUpper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the upper-case version of a given string. </p>
<p>NB: This function changes the parameter 'value'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>string value to be converted to upper case </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting string (same as 'value') </dd></dl>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="a61132d71787b968a6cd6b31feebf444c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int OFStandard::ftoa_alternate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert value to alternate form. </p>
<p>The result will always contain a decimal point, even if no digits follow the point. For g and G conversions, trailing zeroes will not be removed from the result. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ofstd/include/dcmtk/ofstd/ofnetdb.h</li>
<li>ofstd/include/dcmtk/ofstd/ofstd.h</li>
</ul>
</div><!-- contents -->
<p>
<hr>
<small>
Generated on Sun Jun 1 2014 for <a href="http://www.dcmtk.org/">DCMTK</a> Version 3.6.1 20131114 by <a href="http://www.doxygen.org/">Doxygen</a> 1.8.1.2
</small>
